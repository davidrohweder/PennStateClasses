/*	Author: 	David Rohweder	Date: 		2-26-2022	Project:	Homework 3*/// Project Includes#include <iostream>#include <sys/time.h>#include <math.h>#include <stdio.h>#include <stdlib.h>#include "sd_thread.h"#include <omp.h>using namespace std;// Start Code Region/*	calc mean and sd and min,max*/STDDEV_RESULT* calcSdThread(double *A, long N, int P){   struct STDDEV_RESULT* res = new STDDEV_RESULT;       double sd_temp, mean, sd;	volatile double min, max;    min = RAND_MAX;    max = 0.0;    sd = 0;    sd_temp = 0;    mean = 0;	omp_set_num_threads(P);// perform the summation for the mean#pragma omp parallel for reduction(+:mean) num_threads(P)	for (int i = 0; i < N; i++) {		mean += A[i];	}    mean /= (double) N;// perform the summation for the standard deviation#pragma omp parallel for reduction(+:sd_temp) reduction(max:max) reduction(min:min) num_threads(P)	for(int i = 0; i < N; i++) {		sd_temp += (A[i] - mean) * (A[i] - mean);		if (max < A[i]) {			max = A[i];		}		if (min > A[i]) {			min = A[i];		}	}    sd = sqrt(sd_temp / (double) N);	// store off the values to return 	res->mean = mean;	res->min = min;	res->max = max;	res->stddev = sd;	    return res;}/*	Find count of elements over T value and store arr loc*/THRESH_RESULT *findThreshValuesThread(double *A, long N, double T, int P){	THRESH_RESULT *p_tmpResult = new THRESH_RESULT;	long c = 0;		omp_set_num_threads(P);#pragma omp parallel for reduction(+:c) num_threads(P)	for (long i = 0; i < N; i++) {		if (A[i] > T) {			c++;		}	}	p_tmpResult->li_threshCount = c;	p_tmpResult->pli_list = new long[c];	c = 0;#pragma omp parallel for num_threads(P)    for (long i = 0; i < N; i++) {		if (A[i] > T) {			#pragma omp critical			{				p_tmpResult->pli_list[c] = i;				c++;			}		}	}	return p_tmpResult;}