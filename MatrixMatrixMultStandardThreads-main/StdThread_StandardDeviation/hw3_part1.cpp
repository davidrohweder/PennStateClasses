/*	Author: 	David Rohweder	Date: 		2-26-2022	Project:	Homework 3*/// Project Includes#include <iostream>#include <sys/time.h>#include <math.h>#include <stdio.h>#include <stdlib.h>#include "hw3_part1.hpp"#include <thread>#include <mutex>using namespace std;// Global Definesstd::mutex m;typedef struct threadInformation {	int start;	int stop;	double *ptrA;	THRESH_RESULT *ptrB;	double value;	double value1; 	double value2;} threadInformation;int threshCounter;// Start Code Region/*  threaded function for calculating mean*/void threaded_mean(threadInformation& info) {	double localMean = 0.0;	// perform the summation for the mean	for(long i = info.start; i < info.stop; i++) {		localMean += info.ptrA[i];	}	info.value = localMean;}/*  threadded min, max, and mainly standard deviation.*/void threaded_Sd_Min_Max(double mean, threadInformation& info) {	double localSd = 0.0, localMax = 0.0;	double localMin = info.value2;	for(long i = info.start; i < info.stop; i++) {		localSd += (info.ptrA[i] - mean) * (info.ptrA[i] - mean);		if (localMax < info.ptrA[i]) {			localMax = info.ptrA[i];		}		if (localMin > info.ptrA[i]) {			localMin = info.ptrA[i];		}	}	info.value = localSd;	info.value1 = localMax;	info.value2 = localMin;}/*  calculates mean, standard deviation, min, max.*/STDDEV_RESULT* calcSdThread(double *A, long N, int P){    	struct STDDEV_RESULT* res = new STDDEV_RESULT;     	double sd_temp, mean, min, max, sd;    	int i = 0;    	min = A[0]; // 0.0 can be less than min    	max = 0.0;     	sd = 0.0;    	mean = 0.0;	// Define threads 	std::thread threads[P];	threadInformation* threadInfo = new threadInformation[P];	// Give each thread information	for (int i = 0; i < P; i++) {		threadInfo[i].start = i * (N/P);		threadInfo[i].stop = (i + 1) * (N/P);				if (threadInfo[i].stop > N) {		    threadInfo[i].stop = N;		}				threadInfo[i].ptrA = A;		threadInfo[i].value = 0.0;		threadInfo[i].value1 = A[0];		threadInfo[i].value2 = A[0];	}	/*		Def region: calc mean	*/	// Fire off threads	for (i = 0; i < P; i++) {		threads[i] = std::thread(threaded_mean, std::ref(threadInfo[i]));	}	// Join threads	for (i = 0; i < P; i++) {		threads[i].join();	}	// Calculate 	for (i = 0; i < P; i++) {		mean += threadInfo[i].value;	}	mean /= (double) N;	/*		Def region: calc Sd	*/	// Fire off threads	for (int i = 0; i < P; i++) {		threads[i] = std::thread(threaded_Sd_Min_Max, mean, std::ref(threadInfo[i]));	}	// Join threads	for (int i = 0; i < P; i++) {		threads[i].join();	}	// Calculate 	for (i = 0; i < P; i++) {		sd += threadInfo[i].value;	}	sd = sqrt(sd / (double) N);	// Find min - max	for(i = 0; i < P; i++) {		if (max < threadInfo[i].value1) {			max = threadInfo[i].value1;		}		if (min > threadInfo[i].value2) {			min = threadInfo[i].value2;		}	}	// store off the values to return 	res->mean = mean;	res->min = min;	res->max = max;	res->stddev = sd;	delete[] threadInfo;    	return res;}/*  threadded threshhold function that counts number of elements over thres. T value.*/void threaddedThresh(threadInformation& info) {	// info.value1 = c ::: info.value = T	for(int i = info.start; i < info.stop; i++) {		if (info.ptrA[i] > info.value) {			info.value1 += 1;		}	}}/*  threadded threshhold function that puts elements over thres T value into ret. arr.*/void threaddedThreshArr(threadInformation& info) {	// info.value = T	// store the index locations of the values over threshold	for (int i = info.start; i < info.stop; i++) {		if (info.ptrA[i] > info.value) {			m.lock();			info.ptrB->pli_list[threshCounter] = i;			threshCounter += 1;			m.unlock();		}	}}/*	Find count of elements over T value and store arr loc*/THRESH_RESULT *findThreshValuesThread(double *A, long N, double T, int P) {	THRESH_RESULT* p_tmpResult = new THRESH_RESULT;	int i = 0, c = 0;	// Define threads 	std::thread threads[P];	threadInformation* threadInfo = new threadInformation[P];	// Give each thread information	for (i = 0; i < P; i++) {		threadInfo[i].start = i * (N/P);		threadInfo[i].stop = (i + 1) * (N/P);				if (threadInfo[i].stop > N) {		    threadInfo[i].stop = N;		}				threadInfo[i].ptrA = A;		threadInfo[i].ptrB = p_tmpResult;		threadInfo[i].value = T; // value in thread func is T (thresh)		threadInfo[i].value1 = 0.0; //value 1 in thread func is C		threadInfo[i].value2 = 0.0; 	}	/*		Def Region: thres count	*/	// Fire off threads	for (i = 0; i < P; i++) {		threads[i] = std::thread(threaddedThresh, std::ref(threadInfo[i]));	}	// Join threads	for (i = 0; i < P; i++) {		threads[i].join();	}	// calculate c	for (i = 0; i < P; i++) {		c += threadInfo[i].value1;	}		/*		Def Region: thres arr	*/	p_tmpResult->li_threshCount = c;	p_tmpResult->pli_list = new long[c];	// Fire off threads	for (i = 0; i < P; i++) {		threads[i] = std::thread(threaddedThreshArr, std::ref(threadInfo[i]));	}	// Join threads	for (i = 0; i < P; i++) {		threads[i].join();	}	delete[] threadInfo;	return p_tmpResult;}